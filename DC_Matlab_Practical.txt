                 DC_Prcatical_5


clc;
clear all;
M = 16;                  
x = 0:M-1;             
N = 1;                  
OFF = 0;              
z = pskmod(x, M, OFF);    % Modulate symbols using MPSK
% Scatter plot
figure(1)
scatterplot(z, N, OFF, 'r+');
title('16-PSK Constellation');
grid on;
   

  OR




clc;
clear all;
M = 16;                 % MPSK order
x = 0:M-1;              % Symbol indices
phase_offset = 0;       % Phase offset in radians
% Manual PSK modulation (same math as pskmod)
z = exp(1j * (2*pi*x/M + phase_offset));
% Scatter plot
figure(1);
scatter(real(z), imag(z), 'r+');
axis equal;
grid on;
title('16-PSK Constellation');
xlabel('In-phase');
ylabel('Quadrature');




















   DC_Practical_6
clc;
clear all;
close all;
M = 16;
N = log2(M);
SNR = 25;

choice = input('Enter 1:BPSK, 2:QPSK, 3:MSK, 4:16-QAM, 5:16-PSK, 6:16-FSK: ');

if choice<4   % BER for BPSK, QPSK, and MSK
   pe = 0.5 * erfc(sqrt(SNR));
  
elseif choice == 4
   pe = 2 * erfc(sqrt(0.4 * SNR));
  
elseif choice == 5
   pe = erfc(sqrt(SNR) * sin(pi/M));
  
elseif choice == 6
   pe = ((M-1)/2) * erfc(sqrt(N * SNR / 2));
  
else
   pe = NaN;
   fprintf('Error: Invalid choice.\n');
end
if ~isnan(pe)
   Error_Probability = pe
end


















DC_Practical_7


N = 64; CP = 16; % Number of subcarriers
% Length of cyclic prefix
numSym = 5; % Number of OFDM symbols
% Generate random bits (2 bits per QPSK symbol)
bits = randi([0 1], N*2*numSym, 1);
% QPSK modulation: map bits to symbols
bits_reshape = reshape(bits, 2, []).';
symbols = (1 - 2*bits_reshape(:,1)) + 1j*(1 - 2*bits_reshape(:,2));
symbols = symbols / sqrt(2); % Normalize power
% Group symbols into OFDM symbols (rows)
ofdm_symbols = reshape(symbols, N, numSym).';
% IFFT to get time domain OFDM signal
time_domain = ifft(ofdm_symbols, N, 2);
% Add cyclic prefix (copy last CP samples to front)
ofdm_with_cp = [time_domain(:, end-CP+1:end) time_domain];
% Received signal (ideal channel, no noise)
received = ofdm_with_cp;
% Remove cyclic prefix
received_no_cp = received(:, CP+1:end);
% FFT to recover frequency domain symbols
received_symbols = fft(received_no_cp, N, 2);
% Flatten for demodulation
received_symbols = received_symbols.';
% QPSK demodulation (decide bits from real and imag parts)
received_bits = zeros(length(bits), 1);
received_bits(1:2:end) = real(received_symbols(:)) < 0;
received_bits(2:2:end) = imag(received_symbols(:)) < 0;
% Calculate errors
numErrors = sum(bits ~= received_bits);
BER = numErrors / length(bits);
fprintf('Bit errors: %d\nBit error rate: %f\n', numErrors, BER);
symbol_idx = 1;
% Frequency domain (QPSK symbols on subcarriers)
figure;
stem(0:N-1, abs(ofdm_symbols(symbol_idx, :)));
title('OFDM Symbol in Frequency Domain (Magnitude)');
xlabel('Subcarrier Index');
ylabel('Magnitude');
grid on;
% Time domain OFDM symbol (with cyclic prefix)
figure;
plot(real(ofdm_with_cp(symbol_idx, :)));
title('OFDM Symbol in Time Domain (Real Part)');
xlabel('Sample Index');
ylabel('Amplitude');
grid on;
DC_Practical_8
clc;
clear all;
close all;
i=input('Enter no. of elements=');
q=input('Enter joint probabilities matrix=');
sum=0;
%probability P(x)
for n=1:i
w=0;
for m=1:i
p(n)=w+q(n,m);
w=p(n);
end
end
disp('P(x):');
disp(p);
% entropy H(x)
for n=1:i
H=sum+(p(n)*log2(1/p(n)));
sum=H;
end
disp('H(x): ');
disp(H);
%conditional probability matrix
1
for n=1:i
for m=1:i
a(n,m)=q(n,m)/p(n);
end
end
disp('P(Y/X):');
disp(a);
% entropy H(Y/X)
d=0;
for n=1:i
for m=1:i
if(a(n,m)>0)
H1=d+(q(n,m)*log2(1/a(n,m)));
d=H1
end
end
end
disp('H(Y/X):');
disp(H1);
% probability P(Y)
for n=1:i
w=0;
for m=1:i
s(n)=w+q(m,n);
2
w=s(n);
end
end
disp('P(Y):');
disp(s);% entropy H(Y)
k=0;
for n=1:i
H2=k+(s(n)*log2(1/s(n)));
k=H2;
end
disp('H(Y): ');
disp(H2);
% MI
m=H2-H1;
disp('MI-');
disp(m);
%​​Enter no. of elements=3
%Enter joint probabilities matrix=[0.27 0.03 0;0 0.2 0.05;0 0.135 0.315]

DC_Practical_9

clc;
clear all;
close all;
code_length=0;
symbols=[1:5];
p=[0.4 0.15 0.15 0.15 0.15];
[dict,avglen]=huffmandict(symbols,p);
avginfo=0;
for i=1:length(p)
avginfo=avginfo+p(i)*log2(1/p(i));
end
Efficiency=avginfo*100/avglen;
sig=randsrc(1,100,[symbols;p]);
hcode=huffmanenco(sig,dict);
decode=huffmandeco(hcode,dict);
code_length=length(hcode);
display(avginfo);
display(Efficiency);
isequal(sig,decode)














DC_Practical_10

% Given H Matrix
H = [1 1 1 0 1 0 0;
    0 1 1 1 0 1 0;
    1 1 0 1 0 0 1];
k = 4;
n = 7;
% Generating G Matrix
% Taking the H Matrix Transpose
P = H';
% Making a copy of H Transpose Matrix
L = P;
% Taking the last 4 rows of L and storing
L((5:7), : ) = [];
% Creating a Identity matrix of size K x K
I = eye(k);
% Making a 4 x 7 Matrix
G = [I L]
% Generate U data vector, denoting all information sequences
no = 2 ^ k;
% Iterate through an Unit-Spaced Vector
for i = 1 : 2^k
   % Iterate through Vector with Specified Increment
   % or in simple words here we are decrementing 4 till we get 1
   for j = k : -1 : 1
       if rem(i - 1, 2 ^ (-j + k + 1)) >= 2 ^ (-j + k)
           u(i, j) = 1;
       else
           u(i, j) = 0;
       end
   % To avoid displaying each iteration/loop value
   % echo off; % 'echo' is for scripts, not functions. Removed for clarity.
   end
end
% echo on;
u
% Generate CodeWords
c = rem(u * G, 2)
% Find the min distance
w_min = min(sum((c(2 : 2^k, :))'))
% Given Received codeword
r = [0 0 0 1 0 0 0];
r
p = [G(:, n - k + 2 : n)]; % This line is not used, but left as per request
%Find Syndrome
ht = transpose(H)
s = rem(r * ht, 2)
error_found = false; % Add a flag
error_bit = 0;       % Variable to store the error position
for i = 1 : 1 : size(ht, 1) % size(ht,1) is safer, it's 7
  
   % Was: if(ht(i,1:3)==s)
   if isequal(ht(i, 1:3), s)
      
       r(i) = 1-r(i); % Flip the bit
       error_found = true;
       error_bit = i;
       break;
   end
end
% Display results based on whether an error was found
if error_found
   disp('The Error is in bit:')
   disp(error_bit)
   disp('The Corrected Codeword is :')
   disp(r)
else
   % This handles the case where s = [0 0 0]
   disp('No correctable (single-bit) error detected.')
   disp('The Codeword is :')
   disp(r)
end

